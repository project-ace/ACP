.\" Copyright (c) 2014 Kyushu University.  All rights reserved.
.TH #COMMAND# 1 "#ACP_DATE#" "#PACKAGE_VERSION#" "#PACKAGE_NAME#"
.
.SH NAME
#COMMAND# -- #PROJECT# #LANGUAGE# wrapper compiler
.
.SH SYNTAX
#COMMAND# [-ndev <network device>] ...
.
.SH OPTIONS
.TP
.B -ndev
Switch the network device.
\fIib\fR: InfiniBand
\fIudp\fR: UDP
.PP
See the man page for your underlying #LANGUAGE# compiler for other
options that can be passed through #COMMAND#.
.
.
.SH DESCRIPTION
.PP
Conceptually, the role of these commands is quite simple:
transparently add relevant compiler and linker flags to the user's
command line that are necessary to compile / link #PROJECT#
programs, and then invoke the underlying compiler to actually perform
the command.
.
.PP
As such, these commands are frequently referred to as "wrapper"
compilers because they do not actually compile or link applications
themselves; they only add in command line flags and invoke the
back-end compiler.
.
.
.SS Wrapper compilers
\fIacpcc\fR, \fIacpgc\fR, \fIacpc++\fR, \fIacpcxx\fR, and \fIacpfc\fR 
(not provided yet).  Note that \fIacpc++\fR, and \fIacpcxx\fR all invoke 
the same underlying C++ compiler with the same options.
.
.
.SS Overview
\fI#COMMAND#\fR is a convenience wrappers for the underlying
#LANGUAGE# compiler.  Translation of an #PROJECT# program requires the
linkage of the #PROJECT#-specific libraries which may not reside in
one of the standard search directories of ld(1).  It also often
requires the inclusion of header files what may also not be found in a
standard location.
.
.PP
\fI#COMMAND#\fR passes its arguments to the underlying #LANGUAGE#
compiler along with the -I, -L and -l options required by #PROJECT#
programs.
.
.PP
The #PROJECT# Team \fIstrongly\fR encourages using the wrapper
compilers instead of attempting to link to the #PROJECT# libraries
manually.  This allows the specific implementation of #PROJECT# to
change without forcing changes to linker directives in users'
Makefiles.  Indeed, the specific set of flags and libraries used by
the wrapper compilers depends on how #PROJECT# was configured and
built; the values can change between different installations of the
same version of #PROJECT#.
.
.
.SH NOTES
.PP
It is possible to make the wrapper compilers multi-lib aware.  That
is, the libraries and includes specified may differ based on the
compiler flags specified (for example, with the GNU compilers on
Linux, a different library path may be used if -m32 is seen versus
-m64 being seen).  This is not the default behavior in a standard
build, but can be activated (for example, in a binary package
providing both 32 and 64 bit support).
.
.
.SH ENVIRONMENT VARIABLES
.PP 
By default, the wrappers use the compilers that were selected when
#PROJECT# was configured.  These compilers were either found
automatically by Open MPI's "configure" script, or were selected by
the user in the CC, CXX, F77, and/or FC environment variables 
before "configure" was invoked.  Additionally, other arguments
specific to the compiler may have been selected by configure.
.
.
.PP
Valid value names are:
.
.TP
CPPFLAGS
Flags added when invoking the preprocessor (C or C++)
.
.TP
LDFLAGS
Flags added when invoking the linker (C, C++, or Fortran)
.
.TP
LIBS
Libraries added when invoking the linker (C, C++, or Fortran)
.
.TP
CC
C compiler
.
.TP
CFLAGS
C compiler flags
.
.TP
CXX
C++ compiler
.
.TP
CXXFLAGS
C++ compiler flags
.
.
.TP
FC
Fortran compiler
.
.TP
FCFLAGS
Fortran compiler flags
